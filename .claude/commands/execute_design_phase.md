---
name: execute_design_phase
description: "バッチタスクワークフローの設計・計画フェーズ（フェーズ1Aと1B）のみを実行し、detailed_design.yamlとplan.mdファイルを生成します。"
category: workflow
personas: [batch-architect, code-reviewer, db-expert]
---

# execute_design_phase - 設計・計画フェーズ実行コマンド

## トリガー
- このコマンドはバッチ開発タスクの設計・計画フェーズのみを実行するために使用されます。
- `instructions/tickets/BA10601.yaml`などのタスク仕様ファイルをユーザーが提供した際に起動されます。

## 行動指針
自律的な**設計リーダー**として行動します。あなたのミッションは、仕様ファイル（`BA*.yaml`）を受け取り、2つの重要な設計成果物（詳細設計書と実装計画）を作成することです。フェーズ1A（詳細設計）とフェーズ1B（実装計画）のみを実行し、その後停止します。各フェーズには品質確保のためのレビューサイクルが含まれます。プロセスは `設計 -> レビュー -> （必要に応じて）修正 -> 計画 -> レビュー -> （必要に応じて）修正 -> 完了` です。

## 重点領域
- **設計品質**: 包括的で機械可読な設計ドキュメントの作成
- **計画精度**: 詳細でTDDベースの実装計画の生成
- **レビュー準拠**: すべての出力が仕様とアーキテクチャ要件を満たすことを確認
- **DB分析**: テストデータ準備のためのデータベース依存関係を積極的に特定

## 主要アクション＆ワークフロー
**このワークフローはフェーズ1Aと1Bのみを実行し、その後停止します。**

### フェーズ1A: 詳細設計
1. **設計フェーズの開始宣言**: `フェーズ1A開始。仕様から詳細設計を生成中...`
2. **詳細設計のためにアーキテクトに委譲**:
   @agent-batch-architect
   **指示**: これは詳細設計フェーズです。YAML形式で包括的な設計ドキュメントを作成してください。
   **入力**: 提供されたチケット仕様ファイル
   **出力**: /output/[task_id]/[task_id]_detailed_design.yaml
3. **詳細設計のレビュー**: `@agent-code-reviewer`を呼び出して以下の点に特に注意して設計を検証:
   - **🔴 決定の一元化（重要）**: 設計に代替アプローチや「AまたはB」のオプションが存在しないことを確認。各技術的決定には厳密に1つの選択された解決策が必要。「オプションAまたはオプションB」や「XまたはYで実行可能」といったフレーズがある設計は却下。
   - **🔴 契約の正確性（重要）**: すべての契約（Mapperメソッド名、SQL namespace/id、resultType、テストデータセットパス）が厳密で交渉不可能な値として指定されていることを確認。範囲指定や「〜べき」ではなく、「厳密に〜でなければならない」のみ。
   - **🔴 責任の単一性（重要）**: 各責任が厳密に1つのレイヤーに割り当てられていることを確認（日付フォーマット：SQLまたはFieldExtractorのいずれか、バリデーション：JobParametersValidatorまたはビジネスロジックのいずれか）。
   - **共通基盤の前提**: `BatchBaseConfig`と`CustomerClient`のような共通コンポーネントへの依存関係の文書化を確認
   - **バリデーションの完全性**: 日付パラメータにフォーマットと存在の両方のバリデーションが含まれることを確認
   - **デフォルトパラメータメカニズム**: どのアプローチ（SpEL vs Supplierパターン）を使用するかと理由が明確に指定されていることを確認
   - **出力フォーマット処理**: 日付フォーマットが必要な場合のカスタムFieldExtractor設計をチェック
   - **NULL値処理**: FieldExtractor設計がNULLから空文字列への変換を処理することを確認
   - **🔴 CSVヘッダー行（重要）**: I/F仕様書でヘッダー要件がチェックされていることを確認。不確かな場合は両方のシナリオを設計に含める必要がある
   - **データ整合性**: JOIN動作と欠落マスタデータの処理の文書化をチェック
   - **パフォーマンス設定**: データベースリーダーにfetchSize設定が含まれることをチェック
   - **運用ログ**: ログ戦略に特定のログレベル（INFO/WARN/ERROR/DEBUG）とビジネス関連メッセージが含まれることを確認
   - **🔴 データモデルの分離（重要）**: 設計に2つの異なるデータモデルが含まれることを確認:
     - リーダーモデル（例：`ProjectAndCodeNameDetail`）DB マッピング用
     - ライターモデル（例：`ExportProjectsInPeriodItem`）CSV 出力用
     - ItemProcessorが適切な変換のために`<ReaderModel, WriterModel>`として定義されていることを確認
   - **再実行戦略＆トランザクション動作**: 文書に以下が含まれることを確認:
     - ファイル上書きポリシー（`shouldDeleteIfExists(true)`）
     - 空ファイル作成ポリシー（`shouldDeleteIfEmpty(false)`）
     - チャンク失敗動作とリカバリーアプローチ
4. **ゲート＆ループ**: 承認されない場合、承認されるまでフィードバックと共にアーキテクトに戻る。
5. **完了の宣言**: `フェーズ1A完了。詳細設計が承認されました。`

### フェーズ1B: 実装計画
1. **計画フェーズの開始宣言**: `フェーズ1B開始。承認された設計から段階的な実装計画を生成中...`
2. **実装計画のためにアーキテクトに委譲**:
   @agent-batch-architect
   **指示**: これは実装計画フェーズです。Markdown形式でTDDベースの実装計画を作成してください。
   **入力**: /output/[task_id]/[task_id]_detailed_design.yaml
   **出力**: /output/[task_id]/[task_id]_plan.md
3. **積極的なDB分析**: `@agent-db-expert`を呼び出して計画を分析し、テストデータ要件を生成。
4. **実装計画のレビュー**: `@agent-code-reviewer`を呼び出して計画を検証、以下を確認:
   - **🔴 契約の一貫性の強制（重要）**: すべてのステップが厳密なメソッドシグネチャ、SQL namespace/id、resultType、テストデータセットファイル名を変更なしで指定していることを確認。詳細設計の決定はすべてのステップを通じて一貫して参照される必要がある。
   - **🔴 単一アプローチへの準拠（重要）**: 各ステップが日付フォーマットをSQL（Processorパススルー）またはFieldExtractor（SQL生型）のどちらで処理するか明確に述べていることを確認 - 同じ計画で両方のアプローチを許可しない。
   - **🔴 テスト資産の命名規則（重要）**: すべてのテストデータセットパス、ファイル名、テーブル名、カラム参照が既存プロジェクトの規則に厳密に従うことを確認。変更や「柔軟な」命名は不可。
   - **🔴 モデル実装ステップ（重要）**: 計画に正しい順序で3つの異なるステップが含まれることを確認:
     1. リーダーモデル実装ステップ（DBマッピングモデル）
     2. ライターモデル実装ステップ（CSV出力モデル）
     3. ItemProcessor変換ステップ（リーダー→ライター変換）
   - **専用バリデーターステップ**: JobParametersValidator実装のための特定のステップが存在することを確認
   - **デフォルトパラメータステップ**: デフォルト値メカニズム実装のステップが含まれることを確認
   - **カスタムFieldExtractorステップ**: 日付フォーマットとnull処理実装のステップが含まれることを確認
   - **パフォーマンス設定ステップ**: fetchSize設定がリーダー実装で対処されることを確認
   - **インフラエラーテスト**: DB接続エラー、ファイルI/Oエラー、APIタイムアウトのテストが計画に含まれることを確認
   - **境界値テスト**: プロジェクト開始/終了境界での日付を使用したテストをチェック
   - **テストデータの完全性**: 統合テストステップがすべての関連テーブルに言及していることをチェック
   - **CSVフォーマット検証**: テストステップに以下が含まれることを確認:
     - 日付フォーマット検証（yyyy/MM/dd）
     - NULL値処理検証
     - **ソート順検証**: 正しい順序付けのための行ごとの比較
     - **ヘッダー行検証**: 最初の行の内容チェック
5. **ゲート＆ループ**: 承認されない場合、承認されるまでフィードバックと共にアーキテクトに戻る。
6. **完了の宣言**: `フェーズ1B完了。実装計画が承認されました。`

### ワークフロー完了
1. **最終サマリー**: 生成された成果物のサマリーを提示:
   - 詳細設計: `/output/[task_id]/[task_id]_detailed_design.yaml`
   - 実装計画: `/output/[task_id]/[task_id]_plan.md`
   - DB要件: `/output/[task_id]/[task_id]_db_requirements.md`
2. **終了メッセージ**: `設計と計画フェーズが完了しました。実装フェーズの準備ができました。`

## 出力
- **詳細設計ドキュメント（`/output/[task_id]/[task_id]_detailed_design.yaml`）**: 機械可読な設計ブループリント
- **実装計画（`/output/[task_id]/[task_id]_plan.md`）**: 段階的なTDD実行計画
- **DB要件レポート（`/output/[task_id]/[task_id]_db_requirements.md`）**: テストデータ依存関係分析

## 境界
**実行する内容:**
- フェーズ1Aと1Bを自律的に実行
- 設計とレビューのために専門エージェントを編成
- 必要なすべての設計成果物を作成
- 計画フェーズ完了後に停止

**実行しない内容:**
- 実装コード生成の実行
- 設計レビュー以外のテストや検証の実行
- フェーズ2（実装）への進行
- ソースコードファイルの変更