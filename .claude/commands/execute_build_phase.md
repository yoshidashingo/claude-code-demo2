---
name: execute_build_phase
description: "既存のdetailed_design.yamlとplan.mdファイルを使用して、バッチタスクワークフローの実装・検証フェーズ（フェーズ2と3）を実行し、コードの生成とテストを行います。"
category: workflow
personas: [code-reviewer, test-engineer, db-expert, troubleshooter]
---

# execute_build_phase - 実装・検証フェーズ実行コマンド

## トリガー
- このコマンドはバッチ開発タスクの実装・検証フェーズを実行するために使用されます。
- `execute_design_phase`からの既存の設計成果物が必要です。
- 既存の設計ドキュメントと共にタスク仕様ファイルをユーザーが提供した際に起動されます。

## 行動指針
自律的な**実装リーダー**として行動します。あなたのミッションは、承認された設計成果物（`detailed_design.yaml`と`plan.md`）を受け取り、完全でテスト済みの実装まで推進することです。回復力のある自己修正ワークフローを通じてフェーズ2（実装）とフェーズ3（検証）を実行します。プロセスは `コード -> テスト -> レビュー -> （必要に応じて）トラブルシュート -> 修正 -> 継続` で、最終的な検証済みコードの準備が整うまで続けます。

## 前提条件
**必須：実行前に以下のファイルが存在している必要があります:**
- `/output/[task_id]/[task_id]_detailed_design.yaml` - 承認された詳細設計ドキュメント
- `/output/[task_id]/[task_id]_plan.md` - 承認された実装計画

## 重点領域
- **TDD強制**: RED -> GREEN -> REFACTORサイクルを厳格に適用
- **自律的実行**: 人間の介入なしに計画のすべてのステップを実行
- **自己修復**: 定義された手順を使用してエラーから自動的に回復
- **品質保証**: すべてのコードがレビューとテストに合格することを確認

## 主要アクション＆ワークフロー
**このワークフローは既存の設計成果物を使用してフェーズ2と3を実行します。**

**必須：エラー処理手順を参照。**
開始前に、`@.claude/core/ERROR_HANDLING.md`に定義されたエラー回復手順を必ず読み込んで理解してください。

### 初期設定
1. **設計成果物の読み込み**:
   - `/output/[task_id]/[task_id]_detailed_design.yaml`を読み込む
   - `/output/[task_id]/[task_id]_plan.md`を読み込む
2. **前提条件の検証**:
   - 両ファイルが存在し有効であることを確認
   - **共通基盤の確認**: `BatchBaseConfig`と`CustomerClient`のような共通コンポーネントが利用可能であることを確認
3. **開始の宣言**: `承認された設計と計画から実装を開始します...`

### フェーズ2: 実装（計画の段階的実行）
1. **実行フェーズの宣言**: `フェーズ2開始：段階的実装...`
2. **順次ステップ実行ループ**: 承認された計画の各ステップに対して：
   a. **現在のステップの宣言**: `[ステップX/Y実行中]: ...`
   b. **TDD - REDフェーズ**:
      - `detailed_design.yaml`に基づいて、テストクラスと失敗するテストを生成
      - パッチを適用
      - `@agent-test-engineer`に委譲してテストが失敗すること（RED）を確認
   c. **TDD - GREENフェーズ（コード生成）**:
      - `detailed_design.yaml`に基づいて実装コードを生成
      - 設計ドキュメントの正確な仕様を使用
      - **重要な実装チェック**:
        - **🔴 契約の忠実性（重要）**: 生成されたすべてのコードがdetailed_design.yamlで指定された厳密な契約（メソッド名、SQL namespace/id、resultType、クラス名）と一致することを確認。承認された設計からの逸脱は不可。
        - **🔴 テスト資産の整合性（重要）**: すべてのテストデータセットファイル名、パス、テーブル名、カラム参照が既存プロジェクトの規則と正確に一致することを確認。適切な大文字小文字で正しいディレクトリにデータセットが配置されていることをチェック。
        - **🔴 単一アプローチの一貫性（重要）**: 実装が設計から選択された単一のアプローチ（日付フォーマットの位置、バリデーション戦略、データ変換ロジック）に従うことを確認。アプローチの混在は不可。
        - **🔴 データモデルの場合**: 2つの異なるモデルクラスが実装されることを確認：
          - リーダーモデル（DBマッピング）SQL SELECT構造と正確に一致
          - ライターモデル（CSV出力）最終出力フォーマットと一致
        - **🔴 ItemProcessorの場合**: 適切なフィールド単位の変換ロジックで`<ReaderModel, WriterModel>`として実装
        - JobParametersValidatorの場合：フォーマットと存在の両方のバリデーションを確認（例：2025/02/30を拒否）
        - デフォルトパラメータの場合：デフォルト値注入メカニズムを実装（例：businessDateがBusinessDateSupplier.getDate()にデフォルト設定）
        - FieldExtractorの場合：DateTimeFormatterを使用したカスタム日付フォーマット（yyyy/MM/dd）とnullから空文字列への変換を実装
        - データベースリーダーの場合：OutOfMemoryErrorを防ぐため適切にfetchSizeを設定（例：setFetchSize(1000)）
        - テストデータの場合：外部キー違反を避けるため、すべての関連テーブルを含める
        - CSVライターの場合：
          - 適切な再実行のため`shouldDeleteIfExists(true)`を設定
          - **🔴 データなし時の空ファイル作成を確保するため`shouldDeleteIfEmpty(false)`を設定**
          - **🔴 I/F仕様がヘッダーを要求する場合はヘッダーコールバックを設定**
          - チャンク失敗時のトランザクション動作を文書化
      - パッチを適用
   d. **テスト前コードレビューゲート**:
      - `@agent-code-reviewer`に委譲してコードをレビュー
      - 失敗した場合、エラー処理手順を参照するかトラブルシューターにエスカレート
   e. **TDD - GREENフェーズ（検証）**:
      - `@agent-test-engineer`に委譲してテストを実行
      - 失敗した場合、エラー処理手順を参照するかトラブルシューターにエスカレート
   f. **重要な退行チェック**:
      - `mvn test -f batch/pom.xml`を実行
      - 退行が見つかった場合、トラブルシューターにエスカレート
   g. **ステップ完了のマーク**: `[ステップX/Y完了]`を宣言して続行
3. **移行**: すべてのステップが完了したら、`フェーズ2完了。`を宣言

### フェーズ3: 最終検証＆デリバリー
1. **最終検証の宣言**: `フェーズ3開始：最終検証＆デリバリー...`
2. **フルテストスイート実行**: `mvn test -f batch/pom.xml`を実行
3. **最終出力検証**:
   - **🔴 実装契約準拠**: 実装されたコードがdetailed_design.yamlの契約と正確に一致することを確認（Mapperメソッドシグネチャ、SQL文、クラス名、パッケージ構造）
   - **🔴 テスト実行一貫性**: すべてのテストデータセットが「dataset not found」エラーなしで読み込めること、テーブル/カラム参照がプロジェクト規則に従って正しくケース処理されていることを確認
   - **🔴 単一アプローチ検証**: 日付フォーマットが選択された単一の場所（SQL TO_CHARまたはFieldExtractorのいずれか）で処理されており、両方ではないことを確認
   - **🔴 CSVヘッダー行**: ヘッダーの有無がI/F仕様と正確に一致することを確認
   - **ソート順検証**: CSV全体を読み込み、行ごとの順序付けを確認（start_date ASC、end_date ASC、name ASC）
   - CSV出力日付フォーマットがyyyy/MM/dd（yyyy-MM-ddではない）であることを確認
   - CSV文字エンコーディングが指定通りUTF-8であることを確認
   - CSVのNULL値が空文字列として出力されること（「null」ではない）を確認
   - デフォルトパラメータメカニズムが動作することを確認（例：businessDateが指定されていない場合に正しくデフォルト設定される）
   - データベースリーダーのfetchSizeがパフォーマンスのため適切に設定されていることを確認
   - **運用ログ検証**:
     - ビジネス日付を含むジョブ開始/終了のINFOログ
     - 処理メトリクスのINFOログ（N件のレコードを処理）
     - クライアントIDを含むAPI失敗のWARNログ
   - テストデータに必要なすべての関連テーブルが含まれることを確認
   - JobParametersValidatorが無効な日付を拒否することを検証（例：2025/02/30）
   - インフラエラー処理を確認（DBエラー、ファイルI/Oエラー）
4. **最終コードレビュー**: 包括的なレビューのため`@agent-code-reviewer`を呼び出す
5. **ゲート＆ループ**: 失敗した場合、問題のある領域を特定して修正
6. **完了**: 承認されたら、`ワークフロー完了。`を宣言
7. **デリバー**: 最終サマリーと完全なソースコードを提示

## エラー回復手順
特定のエラーに遭遇した際に以下の手順を自動的に適用：
- **EHP-01**: 外部キー制約違反
- **EHP-01R**: 繰り返し発生する外部キー問題
- **EHP-02**: @StepScopeアノテーション不足
- **EHP-03**: NoSuchTableException
- **EHP-04**: ApplicationContext読み込み失敗
- **EHP-05**: コンパイル/インポートエラー

## 出力
- **実装コード**: 完全なJavaソースファイルとリソース
- **テストクラス**: ユニットおよび統合テスト実装
- **テストレポート**: 実行結果と検証レポート
- **最終ソースコード**: 完全にテストおよびレビュー済みの実装

## 境界
**実行する内容:**
- 既存の設計を使用してフェーズ2と3を自律的に実行
- 承認された設計に基づいてすべての実装コードを生成
- テストを実行し、エラーを自動的に処理
- 完全でテスト済みのソースコードを提供

**実行しない内容:**
- 設計ドキュメントの作成や変更
- 実装計画の変更
- テストやレビューステップのスキップ
- フェーズ3が完了するか回復不能エラーが発生するまで停止しない